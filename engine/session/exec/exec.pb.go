// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: exec.proto

package exec

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion3

type SessionRequest struct {
	// Types that are valid to be assigned to Msg:
	//
	//	*SessionRequest_Start
	//	*SessionRequest_Stdin
	//	*SessionRequest_Resize
	Msg isSessionRequest_Msg `protobuf_oneof:"msg"`
}

func (m *SessionRequest) Reset()      { *m = SessionRequest{} }
func (*SessionRequest) ProtoMessage() {}
func (*SessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{0}
}
func (m *SessionRequest) String() string { return proto.CompactTextString(m) }

type isSessionRequest_Msg interface {
	isSessionRequest_Msg()
}

type SessionRequest_Start struct {
	Start *Start `protobuf:"bytes,1,opt,name=start,proto3,oneof" json:"start,omitempty"`
}
type SessionRequest_Stdin struct {
	Stdin []byte `protobuf:"bytes,2,opt,name=stdin,proto3,oneof" json:"stdin,omitempty"`
}
type SessionRequest_Resize struct {
	Resize *Resize `protobuf:"bytes,3,opt,name=resize,proto3,oneof" json:"resize,omitempty"`
}

func (*SessionRequest_Start) isSessionRequest_Msg()  {}
func (*SessionRequest_Stdin) isSessionRequest_Msg()  {}
func (*SessionRequest_Resize) isSessionRequest_Msg() {}

func (m *SessionRequest) GetMsg() isSessionRequest_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *SessionRequest) GetStart() *Start {
	if x, ok := m.GetMsg().(*SessionRequest_Start); ok {
		return x.Start
	}
	return nil
}

func (m *SessionRequest) GetStdin() []byte {
	if x, ok := m.GetMsg().(*SessionRequest_Stdin); ok {
		return x.Stdin
	}
	return nil
}

func (m *SessionRequest) GetResize() *Resize {
	if x, ok := m.GetMsg().(*SessionRequest_Resize); ok {
		return x.Resize
	}
	return nil
}

type SessionResponse struct {
	// Types that are valid to be assigned to Msg:
	//
	//	*SessionResponse_Stdout
	//	*SessionResponse_Stderr
	//	*SessionResponse_Exit
	//	*SessionResponse_Ready
	Msg isSessionResponse_Msg `protobuf_oneof:"msg"`
}

func (m *SessionResponse) Reset()      { *m = SessionResponse{} }
func (*SessionResponse) ProtoMessage() {}
func (*SessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{1}
}
func (m *SessionResponse) String() string { return proto.CompactTextString(m) }

type isSessionResponse_Msg interface {
	isSessionResponse_Msg()
}

type SessionResponse_Stdout struct {
	Stdout []byte `protobuf:"bytes,1,opt,name=stdout,proto3,oneof" json:"stdout,omitempty"`
}
type SessionResponse_Stderr struct {
	Stderr []byte `protobuf:"bytes,2,opt,name=stderr,proto3,oneof" json:"stderr,omitempty"`
}
type SessionResponse_Exit struct {
	Exit int32 `protobuf:"varint,3,opt,name=exit,proto3,oneof" json:"exit,omitempty"`
}
type SessionResponse_Ready struct {
	Ready *Ready `protobuf:"bytes,4,opt,name=ready,proto3,oneof" json:"ready,omitempty"`
}

func (*SessionResponse_Stdout) isSessionResponse_Msg() {}
func (*SessionResponse_Stderr) isSessionResponse_Msg() {}
func (*SessionResponse_Exit) isSessionResponse_Msg()   {}
func (*SessionResponse_Ready) isSessionResponse_Msg()  {}

func (m *SessionResponse) GetMsg() isSessionResponse_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *SessionResponse) GetStdout() []byte {
	if x, ok := m.GetMsg().(*SessionResponse_Stdout); ok {
		return x.Stdout
	}
	return nil
}

func (m *SessionResponse) GetStderr() []byte {
	if x, ok := m.GetMsg().(*SessionResponse_Stderr); ok {
		return x.Stderr
	}
	return nil
}

func (m *SessionResponse) GetExit() int32 {
	if x, ok := m.GetMsg().(*SessionResponse_Exit); ok {
		return x.Exit
	}
	return 0
}

func (m *SessionResponse) GetReady() *Ready {
	if x, ok := m.GetMsg().(*SessionResponse_Ready); ok {
		return x.Ready
	}
	return nil
}

type Start struct {
	ContainerId        string            `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	ExecId             string            `protobuf:"bytes,2,opt,name=exec_id,json=execId,proto3" json:"exec_id,omitempty"`
	Command            []string          `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty"`
	Env                map[string]string `protobuf:"bytes,4,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	WorkingDir         string            `protobuf:"bytes,5,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Tty                bool              `protobuf:"varint,6,opt,name=tty,proto3" json:"tty,omitempty"`
	SessionId          string            `protobuf:"bytes,7,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ReplayFromSequence uint64            `protobuf:"varint,8,opt,name=replay_from_sequence,json=replayFromSequence,proto3" json:"replay_from_sequence,omitempty"`
	ClientId           string            `protobuf:"bytes,9,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
}

func (m *Start) Reset()      { *m = Start{} }
func (*Start) ProtoMessage() {}
func (*Start) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{2}
}
func (m *Start) String() string { return proto.CompactTextString(m) }

func (m *Start) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *Start) GetExecId() string {
	if m != nil {
		return m.ExecId
	}
	return ""
}

func (m *Start) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Start) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Start) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *Start) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *Start) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *Start) GetReplayFromSequence() uint64 {
	if m != nil {
		return m.ReplayFromSequence
	}
	return 0
}

func (m *Start) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

type Resize struct {
	Width  int32 `protobuf:"varint,1,opt,name=Width,proto3" json:"Width,omitempty"`
	Height int32 `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
}

func (m *Resize) Reset()      { *m = Resize{} }
func (*Resize) ProtoMessage() {}
func (*Resize) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{3}
}
func (m *Resize) String() string { return proto.CompactTextString(m) }

func (m *Resize) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Resize) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type Ready struct {
	SessionId      string  `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	TerminalSize   *Resize `protobuf:"bytes,2,opt,name=terminal_size,json=terminalSize,proto3" json:"terminal_size,omitempty"`
	ReplayComplete bool    `protobuf:"varint,3,opt,name=replay_complete,json=replayComplete,proto3" json:"replay_complete,omitempty"`
}

func (m *Ready) Reset()      { *m = Ready{} }
func (*Ready) ProtoMessage() {}
func (*Ready) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{4}
}
func (m *Ready) String() string { return proto.CompactTextString(m) }

func (m *Ready) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *Ready) GetTerminalSize() *Resize {
	if m != nil {
		return m.TerminalSize
	}
	return nil
}

func (m *Ready) GetReplayComplete() bool {
	if m != nil {
		return m.ReplayComplete
	}
	return false
}

// ContainerLifecycleRequest for subscribing to container lifecycle events
type ContainerLifecycleRequest struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
}

func (m *ContainerLifecycleRequest) Reset()         { *m = ContainerLifecycleRequest{} }
func (*ContainerLifecycleRequest) ProtoMessage()    {}
func (*ContainerLifecycleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{5}
}
func (m *ContainerLifecycleRequest) String() string { return proto.CompactTextString(m) }

func (m *ContainerLifecycleRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

// ContainerLifecycleEvent represents a container lifecycle event
type ContainerLifecycleEvent struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	EventType   string `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	Status      string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	Timestamp   int64  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExitCode    int32  `protobuf:"varint,5,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	Message     string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ContainerLifecycleEvent) Reset()         { *m = ContainerLifecycleEvent{} }
func (*ContainerLifecycleEvent) ProtoMessage()    {}
func (*ContainerLifecycleEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{6}
}
func (m *ContainerLifecycleEvent) String() string { return proto.CompactTextString(m) }

func (m *ContainerLifecycleEvent) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerLifecycleEvent) GetEventType() string {
	if m != nil {
		return m.EventType
	}
	return ""
}

func (m *ContainerLifecycleEvent) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ContainerLifecycleEvent) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ContainerLifecycleEvent) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ContainerLifecycleEvent) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// ContainerStatusRequest for querying container status
type ContainerStatusRequest struct {
	ContainerId          string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	IncludeResourceUsage bool   `protobuf:"varint,2,opt,name=include_resource_usage,json=includeResourceUsage,proto3" json:"include_resource_usage,omitempty"`
}

func (m *ContainerStatusRequest) Reset()         { *m = ContainerStatusRequest{} }
func (*ContainerStatusRequest) ProtoMessage()    {}
func (*ContainerStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{7}
}
func (m *ContainerStatusRequest) String() string { return proto.CompactTextString(m) }

func (m *ContainerStatusRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerStatusRequest) GetIncludeResourceUsage() bool {
	if m != nil {
		return m.IncludeResourceUsage
	}
	return false
}

// ContainerStatusResponse contains container status information
type ContainerStatusResponse struct {
	ContainerId   string          `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	Status        string          `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	ExitCode      *int32          `protobuf:"varint,3,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	StartedAt     int64           `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	FinishedAt    *int64          `protobuf:"varint,5,opt,name=finished_at,json=finishedAt,proto3" json:"finished_at,omitempty"`
	ResourceUsage *ResourceUsage  `protobuf:"bytes,6,opt,name=resource_usage,json=resourceUsage,proto3" json:"resource_usage,omitempty"`
}

func (m *ContainerStatusResponse) Reset()         { *m = ContainerStatusResponse{} }
func (*ContainerStatusResponse) ProtoMessage()    {}
func (*ContainerStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{8}
}
func (m *ContainerStatusResponse) String() string { return proto.CompactTextString(m) }

func (m *ContainerStatusResponse) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerStatusResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ContainerStatusResponse) GetExitCode() *int32 {
	if m != nil {
		return m.ExitCode
	}
	return nil
}

func (m *ContainerStatusResponse) GetStartedAt() int64 {
	if m != nil {
		return m.StartedAt
	}
	return 0
}

func (m *ContainerStatusResponse) GetFinishedAt() *int64 {
	if m != nil {
		return m.FinishedAt
	}
	return nil
}

func (m *ContainerStatusResponse) GetResourceUsage() *ResourceUsage {
	if m != nil {
		return m.ResourceUsage
	}
	return nil
}

// ResourceUsage contains resource metrics
type ResourceUsage struct {
	CpuPercent   float64 `protobuf:"fixed64,1,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`
	MemoryBytes  uint64  `protobuf:"varint,2,opt,name=memory_bytes,json=memoryBytes,proto3" json:"memory_bytes,omitempty"`
	MemoryLimit  uint64  `protobuf:"varint,3,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	IoReadBytes  uint64  `protobuf:"varint,4,opt,name=io_read_bytes,json=ioReadBytes,proto3" json:"io_read_bytes,omitempty"`
	IoWriteBytes uint64  `protobuf:"varint,5,opt,name=io_write_bytes,json=ioWriteBytes,proto3" json:"io_write_bytes,omitempty"`
}

func (m *ResourceUsage) Reset()         { *m = ResourceUsage{} }
func (*ResourceUsage) ProtoMessage()    {}
func (*ResourceUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{9}
}
func (m *ResourceUsage) String() string { return proto.CompactTextString(m) }

func (m *ResourceUsage) GetCpuPercent() float64 {
	if m != nil {
		return m.CpuPercent
	}
	return 0
}

func (m *ResourceUsage) GetMemoryBytes() uint64 {
	if m != nil {
		return m.MemoryBytes
	}
	return 0
}

func (m *ResourceUsage) GetMemoryLimit() uint64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *ResourceUsage) GetIoReadBytes() uint64 {
	if m != nil {
		return m.IoReadBytes
	}
	return 0
}

func (m *ResourceUsage) GetIoWriteBytes() uint64 {
	if m != nil {
		return m.IoWriteBytes
	}
	return 0
}

// ContainerControlRequest for container control operations
type ContainerControlRequest struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
}

func (m *ContainerControlRequest) Reset()         { *m = ContainerControlRequest{} }
func (*ContainerControlRequest) ProtoMessage()    {}
func (*ContainerControlRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{10}
}
func (m *ContainerControlRequest) String() string { return proto.CompactTextString(m) }

func (m *ContainerControlRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

// ContainerSignalRequest for sending signals to containers
type ContainerSignalRequest struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	Signal      string `protobuf:"bytes,2,opt,name=signal,proto3" json:"signal,omitempty"`
}

func (m *ContainerSignalRequest) Reset()         { *m = ContainerSignalRequest{} }
func (*ContainerSignalRequest) ProtoMessage()    {}
func (*ContainerSignalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{11}
}
func (m *ContainerSignalRequest) String() string { return proto.CompactTextString(m) }

func (m *ContainerSignalRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerSignalRequest) GetSignal() string {
	if m != nil {
		return m.Signal
	}
	return ""
}

// ContainerControlResponse for control operation responses
type ContainerControlResponse struct {
	Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ContainerControlResponse) Reset()         { *m = ContainerControlResponse{} }
func (*ContainerControlResponse) ProtoMessage()    {}
func (*ContainerControlResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_exec, []int{12}
}
func (m *ContainerControlResponse) String() string { return proto.CompactTextString(m) }

func (m *ContainerControlResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ContainerControlResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*SessionRequest)(nil), "dagger.exec.SessionRequest")
	proto.RegisterType((*SessionResponse)(nil), "dagger.exec.SessionResponse")
	proto.RegisterType((*Start)(nil), "dagger.exec.Start")
	proto.RegisterType((*Resize)(nil), "dagger.exec.Resize")
	proto.RegisterType((*Ready)(nil), "dagger.exec.Ready")
	proto.RegisterType((*ContainerLifecycleRequest)(nil), "dagger.exec.ContainerLifecycleRequest")
	proto.RegisterType((*ContainerLifecycleEvent)(nil), "dagger.exec.ContainerLifecycleEvent")
	proto.RegisterType((*ContainerStatusRequest)(nil), "dagger.exec.ContainerStatusRequest")
	proto.RegisterType((*ContainerStatusResponse)(nil), "dagger.exec.ContainerStatusResponse")
	proto.RegisterType((*ResourceUsage)(nil), "dagger.exec.ResourceUsage")
	proto.RegisterType((*ContainerControlRequest)(nil), "dagger.exec.ContainerControlRequest")
	proto.RegisterType((*ContainerSignalRequest)(nil), "dagger.exec.ContainerSignalRequest")
	proto.RegisterType((*ContainerControlResponse)(nil), "dagger.exec.ContainerControlResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ExecClient is the client API for Exec service.
type ExecClient interface {
	Session(ctx context.Context, opts ...grpc.CallOption) (Exec_SessionClient, error)
	ContainerLifecycle(ctx context.Context, in *ContainerLifecycleRequest, opts ...grpc.CallOption) (Exec_ContainerLifecycleClient, error)
	ContainerStatus(ctx context.Context, in *ContainerStatusRequest, opts ...grpc.CallOption) (*ContainerStatusResponse, error)
	ContainerPause(ctx context.Context, in *ContainerControlRequest, opts ...grpc.CallOption) (*ContainerControlResponse, error)
	ContainerResume(ctx context.Context, in *ContainerControlRequest, opts ...grpc.CallOption) (*ContainerControlResponse, error)
	ContainerSignal(ctx context.Context, in *ContainerSignalRequest, opts ...grpc.CallOption) (*ContainerControlResponse, error)
}

type execClient struct {
	cc grpc.ClientConnInterface
}

func NewExecClient(cc grpc.ClientConnInterface) ExecClient {
	return &execClient{cc}
}

func (c *execClient) Session(ctx context.Context, opts ...grpc.CallOption) (Exec_SessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Exec_serviceDesc.Streams[0], "/dagger.exec.Exec/Session", opts...)
	if err != nil {
		return nil, err
	}
	x := &execSessionClient{stream}
	return x, nil
}

type Exec_SessionClient interface {
	Send(*SessionRequest) error
	Recv() (*SessionResponse, error)
	grpc.ClientStream
}

type execSessionClient struct {
	grpc.ClientStream
}

func (x *execSessionClient) Send(m *SessionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *execSessionClient) Recv() (*SessionResponse, error) {
	m := new(SessionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *execClient) ContainerLifecycle(ctx context.Context, in *ContainerLifecycleRequest, opts ...grpc.CallOption) (Exec_ContainerLifecycleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Exec_serviceDesc.Streams[1], "/dagger.exec.Exec/ContainerLifecycle", opts...)
	if err != nil {
		return nil, err
	}
	x := &execContainerLifecycleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Exec_ContainerLifecycleClient interface {
	Recv() (*ContainerLifecycleEvent, error)
	grpc.ClientStream
}

type execContainerLifecycleClient struct {
	grpc.ClientStream
}

func (x *execContainerLifecycleClient) Recv() (*ContainerLifecycleEvent, error) {
	m := new(ContainerLifecycleEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *execClient) ContainerStatus(ctx context.Context, in *ContainerStatusRequest, opts ...grpc.CallOption) (*ContainerStatusResponse, error) {
	out := new(ContainerStatusResponse)
	err := c.cc.Invoke(ctx, "/dagger.exec.Exec/ContainerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execClient) ContainerPause(ctx context.Context, in *ContainerControlRequest, opts ...grpc.CallOption) (*ContainerControlResponse, error) {
	out := new(ContainerControlResponse)
	err := c.cc.Invoke(ctx, "/dagger.exec.Exec/ContainerPause", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execClient) ContainerResume(ctx context.Context, in *ContainerControlRequest, opts ...grpc.CallOption) (*ContainerControlResponse, error) {
	out := new(ContainerControlResponse)
	err := c.cc.Invoke(ctx, "/dagger.exec.Exec/ContainerResume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *execClient) ContainerSignal(ctx context.Context, in *ContainerSignalRequest, opts ...grpc.CallOption) (*ContainerControlResponse, error) {
	out := new(ContainerControlResponse)
	err := c.cc.Invoke(ctx, "/dagger.exec.Exec/ContainerSignal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecServer is the server API for Exec service.
type ExecServer interface {
	Session(Exec_SessionServer) error
	ContainerLifecycle(*ContainerLifecycleRequest, Exec_ContainerLifecycleServer) error
	ContainerStatus(context.Context, *ContainerStatusRequest) (*ContainerStatusResponse, error)
	ContainerPause(context.Context, *ContainerControlRequest) (*ContainerControlResponse, error)
	ContainerResume(context.Context, *ContainerControlRequest) (*ContainerControlResponse, error)
	ContainerSignal(context.Context, *ContainerSignalRequest) (*ContainerControlResponse, error)
}

// UnimplementedExecServer can be embedded to have forward compatible implementations.
type UnimplementedExecServer struct {
}

func (*UnimplementedExecServer) Session(srv Exec_SessionServer) error {
	return status.Errorf(codes.Unimplemented, "method Session not implemented")
}

func (*UnimplementedExecServer) ContainerLifecycle(req *ContainerLifecycleRequest, srv Exec_ContainerLifecycleServer) error {
	return status.Errorf(codes.Unimplemented, "method ContainerLifecycle not implemented")
}

func (*UnimplementedExecServer) ContainerStatus(ctx context.Context, req *ContainerStatusRequest) (*ContainerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerStatus not implemented")
}

func (*UnimplementedExecServer) ContainerPause(ctx context.Context, req *ContainerControlRequest) (*ContainerControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerPause not implemented")
}

func (*UnimplementedExecServer) ContainerResume(ctx context.Context, req *ContainerControlRequest) (*ContainerControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerResume not implemented")
}

func (*UnimplementedExecServer) ContainerSignal(ctx context.Context, req *ContainerSignalRequest) (*ContainerControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContainerSignal not implemented")
}

func RegisterExecServer(s *grpc.Server, srv ExecServer) {
	s.RegisterService(&_Exec_serviceDesc, srv)
}

func _Exec_Session_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExecServer).Session(&execSessionServer{stream})
}

type Exec_SessionServer interface {
	Send(*SessionResponse) error
	Recv() (*SessionRequest, error)
	grpc.ServerStream
}

type execSessionServer struct {
	grpc.ServerStream
}

func (x *execSessionServer) Send(m *SessionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *execSessionServer) Recv() (*SessionRequest, error) {
	m := new(SessionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Exec_ContainerLifecycle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContainerLifecycleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecServer).ContainerLifecycle(m, &execContainerLifecycleServer{stream})
}

type Exec_ContainerLifecycleServer interface {
	Send(*ContainerLifecycleEvent) error
	grpc.ServerStream
}

type execContainerLifecycleServer struct {
	grpc.ServerStream
}

func (x *execContainerLifecycleServer) Send(m *ContainerLifecycleEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Exec_ContainerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecServer).ContainerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagger.exec.Exec/ContainerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecServer).ContainerStatus(ctx, req.(*ContainerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Exec_ContainerPause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecServer).ContainerPause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagger.exec.Exec/ContainerPause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecServer).ContainerPause(ctx, req.(*ContainerControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Exec_ContainerResume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecServer).ContainerResume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagger.exec.Exec/ContainerResume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecServer).ContainerResume(ctx, req.(*ContainerControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Exec_ContainerSignal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerSignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecServer).ContainerSignal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagger.exec.Exec/ContainerSignal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecServer).ContainerSignal(ctx, req.(*ContainerSignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Exec_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dagger.exec.Exec",
	HandlerType: (*ExecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ContainerStatus",
			Handler:    _Exec_ContainerStatus_Handler,
		},
		{
			MethodName: "ContainerPause",
			Handler:    _Exec_ContainerPause_Handler,
		},
		{
			MethodName: "ContainerResume",
			Handler:    _Exec_ContainerResume_Handler,
		},
		{
			MethodName: "ContainerSignal",
			Handler:    _Exec_ContainerSignal_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Session",
			Handler:       _Exec_Session_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ContainerLifecycle",
			Handler:       _Exec_ContainerLifecycle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "exec.proto",
}

var fileDescriptor_exec = []byte{
	// Placeholder file descriptor
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4a, 0xad, 0x48,
	0x4d, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x4e, 0x49, 0x4c, 0x4f, 0x4f, 0x2d,
}
